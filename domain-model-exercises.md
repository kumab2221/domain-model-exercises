# ドメインモデル抽出 — 練習問題と模範解答

---

## 問題の取り組み方

1. 要件文を読み、**名詞**（→ エンティティ/値オブジェクト候補）と**動詞**（→ ドメインイベント/振る舞い候補）に注目する
2. 以下を整理する：
   - **エンティティ（Entity）**: 一意に識別され、ライフサイクルを持つもの
   - **値オブジェクト（Value Object）**: 属性の組み合わせで等価性が決まるもの
   - **集約（Aggregate）**: 整合性の境界。集約ルートを特定する
   - **ドメインイベント（Domain Event）**: ビジネス上重要な「起きたこと」
   - **ドメインサービス**: 特定のエンティティに属さないビジネスロジック
3. 模範解答と見比べて、抜け漏れや粒度の違いを確認する

---

## 【問題 1】初級 — オンライン書店

### 要件

> あなたはオンライン書店のシステムを設計しています。
>
> - 顧客はアカウントを作成し、メールアドレスとパスワードでログインする。
> - 顧客は書籍を検索し、カートに追加できる。カート内の書籍の数量は変更可能。
> - 書籍には ISBN、タイトル、著者、価格、在庫数がある。
> - 顧客はカートの内容を確認し、注文を確定する。
> - 注文には配送先住所が必要。配送先住所は「氏名・郵便番号・都道府県・市区町村・番地」で構成される。
> - 注文確定時に在庫が不足している場合、注文は失敗する。
> - 注文が確定すると、注文ステータスは「確定済み」→「発送済み」→「配達完了」と遷移する。

**問い**: エンティティ、値オブジェクト、集約、ドメインイベントを抽出してください。

---

### 模範解答 1

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 顧客 (Customer) | customerId | メールアドレス, パスワード(ハッシュ) |
| 書籍 (Book) | ISBN | タイトル, 著者, 価格, 在庫数 |
| カート (Cart) | cartId (または customerId と 1:1) | カート明細のリスト |
| 注文 (Order) | orderId | 顧客, 注文明細のリスト, 配送先住所, 注文ステータス |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| メールアドレス (Email) | 文字列（形式バリデーション付き） | 同じ文字列なら同一とみなせる |
| 配送先住所 (ShippingAddress) | 氏名, 郵便番号, 都道府県, 市区町村, 番地 | 属性の組み合わせで等価 |
| 金額 (Money) | 数値, 通貨 | 同額なら区別不要 |
| カート明細 (CartItem) | 書籍(への参照), 数量 | カート内の一行。個別IDは不要 |
| 注文明細 (OrderLine) | 書籍(への参照), 数量, 単価 | 注文確定時の価格スナップショット |
| 注文ステータス (OrderStatus) | 確定済み / 発送済み / 配達完了 | 列挙型で十分 |

#### 集約

| 集約ルート | 含まれるもの | 整合性のルール |
|---|---|---|
| Book | Book 単体 | 在庫数は 0 以上 |
| Cart | Cart + CartItem | カート明細の数量は 1 以上 |
| Order | Order + OrderLine | 注文ステータスの遷移は一方向のみ |
| Customer | Customer 単体 | メールアドレスは一意 |

#### ドメインイベント

- `CartItemAdded` — 商品がカートに追加された
- `OrderPlaced` — 注文が確定された（→ 在庫引き当てのトリガー）
- `OrderShipped` — 注文が発送された
- `OrderDelivered` — 注文が配達完了した

#### 解説ポイント

- **カート明細 vs 注文明細を分ける理由**: カート明細は価格変動に追随するが、注文明細は確定時の単価を保持（スナップショット）する。責務が異なるため別の値オブジェクトにする。
- **Book を独立した集約にする理由**: 在庫数の更新はカートや注文の整合性境界の外で行われるべき。トランザクション境界を分離する。

---

## 【問題 2】中級 — レストラン予約システム

### 要件

> レストランの予約管理システムを設計してください。
>
> - レストランには複数のテーブルがあり、各テーブルには席数（2名席、4名席など）がある。
> - 顧客は、日付・時間帯（ランチ/ディナー）・人数を指定して予約を申し込む。
> - システムは指定された条件に合うテーブルを自動で割り当てる。人数以上の席数を持つ最小のテーブルを優先する。
> - 同じテーブルに同じ日付・時間帯の予約が重複してはならない。
> - 予約にはステータスがあり「仮予約」→「確定」→「来店済み」または「キャンセル」と遷移する。
> - 仮予約は 30 分以内に確定されないと自動キャンセルされる。
> - 顧客が予約をキャンセルした場合、キャンセル料が発生する場合がある。キャンセル料は「来店日の何日前か」によって変わる（3日前まで無料、前日50%、当日100%）。
> - レストランは「定休日」や「臨時休業日」を設定できる。休業日には予約できない。

**問い**: エンティティ、値オブジェクト、集約、ドメインイベント、ドメインサービスを抽出してください。

---

### 模範解答 2

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| レストラン (Restaurant) | restaurantId | 店名, 営業カレンダー |
| テーブル (Table) | tableId | テーブル番号, 席数 |
| 予約 (Reservation) | reservationId | 顧客, テーブル, 予約日時スロット, 人数, ステータス, 仮予約期限 |
| 顧客 (Customer) | customerId | 氏名, 電話番号 |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 予約日時スロット (TimeSlot) | 日付, 時間帯(ランチ/ディナー) | 同じ日付×時間帯なら等価 |
| 席数 (SeatCount) | 数値（1以上の整数） | バリデーション付きの値 |
| 人数 (PartySize) | 数値（1以上の整数） | バリデーション付きの値 |
| 予約ステータス (ReservationStatus) | 仮予約/確定/来店済み/キャンセル | 列挙型 |
| キャンセル料 (CancellationFee) | 金額, 料率 | 計算結果の値 |
| 営業カレンダー (BusinessCalendar) | 定休日の曜日リスト, 臨時休業日リスト | レストランの営業ルール |

#### 集約

| 集約ルート | 含まれるもの | 整合性のルール |
|---|---|---|
| Restaurant | Restaurant + Table + BusinessCalendar | テーブル構成の管理、休業日の管理 |
| Reservation | Reservation 単体 | ステータス遷移ルール、仮予約の期限管理 |

#### ドメインイベント

- `ReservationRequested` — 予約が仮予約として作成された
- `ReservationConfirmed` — 予約が確定した
- `ReservationCancelled` — 予約がキャンセルされた（キャンセル料情報を含む）
- `ReservationExpired` — 仮予約が期限切れで自動キャンセルされた
- `CustomerVisited` — 顧客が来店した

#### ドメインサービス

| サービス | 責務 |
|---|---|
| テーブル割当サービス (TableAssignmentService) | 日付・時間帯・人数から最適なテーブルを選定する。「人数以上の最小テーブル」というルールはどのエンティティにも属さない横断的なロジック。 |
| キャンセル料計算サービス (CancellationFeeCalculator) | 予約日と現在日の差分からキャンセル料率を判定する。ポリシーとして独立させる。 |

#### 解説ポイント

- **テーブル重複チェック**: 「同一テーブル×同一スロットに予約が重複しない」は重要な不変条件。これを Reservation 集約ではなく **TableAssignmentService** でチェックする設計にすると、Reservation 集約をシンプルに保てる。
- **仮予約の自動キャンセル**: 時間経過による状態変化は、ドメインイベント (`ReservationExpired`) + スケジューラ/ポーリングで実現するのが一般的。
- **BusinessCalendar を値オブジェクトにする理由**: 営業カレンダーは Restaurant の一部であり、独立した ID を持つ必要がない。ルール全体をまとめて差し替えられる。

---

## 【問題 3】上級 — オンライン学習プラットフォーム

### 要件

> オンライン学習プラットフォームを設計してください。
>
> - 講師はコースを作成できる。コースにはタイトル、説明、カテゴリ、価格がある。
> - コースは複数のセクションで構成され、各セクションには複数のレッスンがある。
> - レッスンには「動画レッスン」と「テストレッスン」の 2 種類がある。動画レッスンには動画URL と再生時間がある。テストレッスンには問題リスト（複数選択式）がある。
> - コースは「下書き」→「レビュー中」→「公開」のステータスを持つ。レビューは運営が行い、品質基準を満たさない場合は差し戻される。
> - 受講者はコースを購入して受講を開始する。購入時にコースの価格がスナップショットとして記録される。
> - 受講者はレッスンを順番に進め、各レッスンの完了状態が記録される。テストレッスンは正答率 80% 以上で合格。
> - 全レッスンを完了すると修了証が発行される。修了証には受講者名、コース名、修了日が記載される。
> - 受講者はコースにレビュー（1〜5の星評価＋コメント）を投稿できる。レビューは1コースにつき1件まで。
> - 講師には売上の 70% が報酬として支払われる。報酬は月次で集計される。

**問い**: エンティティ、値オブジェクト、集約（境界の理由も）、ドメインイベント、ドメインサービスを抽出してください。

---

### 模範解答 3

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 講師 (Instructor) | instructorId | 氏名, プロフィール |
| コース (Course) | courseId | タイトル, 説明, カテゴリ, 価格, ステータス, 講師 |
| セクション (Section) | sectionId | タイトル, 表示順序 |
| レッスン (Lesson) | lessonId | タイトル, 表示順序, レッスン種別 |
| 受講者 (Student) | studentId | 氏名, メールアドレス |
| 受講登録 (Enrollment) | enrollmentId | 受講者, コース, 購入価格, 進捗, 修了状態 |
| レビュー (Review) | reviewId | 受講者, コース, 星評価, コメント |
| 報酬明細 (PayoutRecord) | payoutId | 講師, 対象年月, 金額, 支払ステータス |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| コースステータス (CourseStatus) | 下書き/レビュー中/公開/差し戻し | 列挙型 |
| 動画情報 (VideoContent) | 動画URL, 再生時間 | 動画レッスンの内容詳細 |
| テスト内容 (QuizContent) | 問題リスト（問題文, 選択肢, 正解） | テストレッスンの内容詳細 |
| レッスン進捗 (LessonProgress) | レッスンへの参照, 完了フラグ, テストスコア | 受講登録内の一行 |
| 修了証 (Certificate) | 受講者名, コース名, 修了日 | 発行後は不変。独自ライフサイクル不要 |
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| 星評価 (Rating) | 1〜5 の整数 | バリデーション付きの値 |
| 合格基準 (PassingCriteria) | 正答率の閾値（80%） | ポリシーを明示化 |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由 |
|---|---|---|
| **Course** | Course + Section + Lesson (+ VideoContent / QuizContent) | コースの構成（セクション・レッスン）は一貫性を持って変更される必要がある。セクションやレッスンが単独で存在する意味はない。 |
| **Enrollment** | Enrollment + LessonProgress のリスト | 進捗管理は受講者×コースの単位で整合性が必要。「全レッスン完了 → 修了」の判定はこの集約内で行う。 |
| **Review** | Review 単体 | 「1コース1レビュー」の制約はあるが、コースや受講登録とは独立してライフサイクルを持つ。 |
| **Instructor** | Instructor 単体 | 講師プロフィールは独立管理。 |
| **Student** | Student 単体 | 受講者情報は独立管理。 |
| **PayoutRecord** | PayoutRecord 単体 | 報酬は月次集計の結果であり、他の集約とトランザクションを共有しない。 |

#### ドメインイベント

- `CourseCreated` — コースが作成された
- `CourseSubmittedForReview` — コースがレビューに提出された
- `CoursePublished` — コースが公開された
- `CourseRejected` — コースが差し戻された
- `CoursePurchased` — コースが購入された（→ Enrollment 作成のトリガー）
- `LessonCompleted` — レッスンが完了した
- `QuizPassed` / `QuizFailed` — テストの合否
- `CourseCompleted` — 全レッスン完了（→ 修了証発行のトリガー）
- `CertificateIssued` — 修了証が発行された
- `ReviewPosted` — レビューが投稿された

#### ドメインサービス

| サービス | 責務 |
|---|---|
| テスト採点サービス (QuizGradingService) | 受講者の回答を受け取り、正答率を計算し、合格基準と照合する。Lesson にも Enrollment にも属しにくい横断ロジック。 |
| 報酬集計サービス (PayoutCalculationService) | 月次で売上を集計し、70% の報酬額を算出して PayoutRecord を生成する。複数の集約（Enrollment の購入価格）を参照する。 |
| 修了証発行サービス (CertificateIssuanceService) | CourseCompleted イベントを受けて修了証を生成する。受講者名・コース名の取得が集約をまたぐため、サービスとして切り出す。 |

#### 解説ポイント

- **Course 集約を大きくしすぎない判断**: Section と Lesson は Course に従属するが、受講者数が多い場合に Course 集約が肥大化する。Enrollment（受講登録）を別集約にすることで、コース定義と受講進捗の更新が競合しない。
- **修了証をエンティティではなく値オブジェクトにする理由**: 修了証は一度発行されたら変更されない。再発行が必要なら新規作成する。独自の ID で管理する必要がなければ値オブジェクトで十分（※ 要件次第ではエンティティもあり得る）。
- **Review の「1コース1件」制約**: この制約は Review 集約単体では保証できない。ドメインサービスまたはリポジトリレベルで一意性を担保する設計が必要。

---

## 抽出のチェックリスト

自分の解答を見直すときに使ってください。

- [ ] 要件に出てくる主要な名詞をすべてエンティティ or 値オブジェクト候補として検討したか
- [ ] 「それ自体を一意に追跡する必要があるか？」でエンティティと値オブジェクトを区別できているか
- [ ] 集約の境界は「一緒に変更されるべきもの」でまとまっているか
- [ ] 集約が大きすぎないか（トランザクション競合のリスク）
- [ ] ビジネスルール（不変条件）がどの集約で守られるか明確か
- [ ] ステータス遷移のルールを値オブジェクト（列挙型）で表現しているか
- [ ] 価格など時点で変わるデータを「スナップショット」として保持しているか
- [ ] 複数の集約にまたがるロジックをドメインサービスとして切り出しているか
- [ ] 重要なビジネスイベントをドメインイベントとして定義しているか
