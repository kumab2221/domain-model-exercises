# ドメインモデル抽出 — 練習問題と模範解答（第2回）

---

## 取り組み方（復習）

1. 要件文から **名詞**（エンティティ/値オブジェクト候補）と **動詞**（振る舞い/イベント候補）を拾う
2. エンティティ・値オブジェクト・集約・ドメインイベント・ドメインサービスを整理する
3. 模範解答と照合し、**抜け漏れ**・**粒度の違い**・**境界の引き方の違い**を確認する

---

## 【問題 1】初級 — フリマアプリ

### 要件

> 個人間で商品を売買できるフリマアプリを設計してください。
>
> - ユーザーはアカウントを作成し、出品者にも購入者にもなれる。
> - 出品者は商品を出品する。商品には商品名、説明文、カテゴリ、商品画像（複数可）、価格がある。
> - 商品のステータスは「出品中」→「取引中」→「売却済み」と遷移する。
> - 購入者は商品を購入する。購入時に商品価格分の残高が購入者から引かれる。
> - ユーザーには残高があり、チャージ（入金）ができる。残高が不足している場合、購入は失敗する。
> - 購入後、出品者は商品を発送する。購入者が受け取り確認をすると取引が完了する。
> - 取引完了時、商品価格から手数料 10% を差し引いた金額が出品者の残高に加算される。
> - 購入者は取引完了後に出品者を評価できる（良い・普通・悪い＋コメント）。評価は取引1件につき1回のみ。

**問い**: エンティティ、値オブジェクト、集約、ドメインイベントを抽出してください。

---

### 模範解答 1

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| ユーザー (User) | userId | ニックネーム, メールアドレス, 残高 |
| 商品 (Item) | itemId | 商品名, 説明文, カテゴリ, 画像リスト, 価格, ステータス, 出品者 |
| 取引 (Transaction) | transactionId | 商品, 購入者, 出品者, 取引ステータス, 購入価格 |
| 評価 (Rating) | ratingId | 取引, 評価者, 被評価者, 評価ランク, コメント |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 金額 (Money) | 数値, 通貨 | 同額なら区別不要 |
| 商品画像 (ItemImage) | 画像URL, 表示順序 | 個別に追跡する必要がない |
| 商品ステータス (ItemStatus) | 出品中/取引中/売却済み | 列挙型 |
| 取引ステータス (TransactionStatus) | 支払済み/発送済み/受取完了 | 列挙型 |
| 評価ランク (RatingGrade) | 良い/普通/悪い | 列挙型 |
| カテゴリ (Category) | カテゴリ名 | 単純な分類値（※ カテゴリ管理が複雑になるならエンティティに昇格） |
| 手数料 (Commission) | 料率(10%), 計算結果の金額 | 計算ルールを明示化 |

#### 集約

| 集約ルート | 含まれるもの | 整合性のルール |
|---|---|---|
| **User** | User 単体 | 残高は 0 以上。チャージ・引き落とし・売上入金の整合性 |
| **Item** | Item + ItemImage | 商品ステータスの遷移ルール。出品中の商品のみ購入可能 |
| **Transaction** | Transaction 単体 | 取引ステータスの遷移は一方向。購入価格はスナップショット |
| **Rating** | Rating 単体 | 1取引1評価の制約 |

#### ドメインイベント

- `ItemListed` — 商品が出品された
- `ItemPurchased` — 商品が購入された（→ 残高引き落とし・取引作成のトリガー）
- `ItemShipped` — 商品が発送された
- `DeliveryConfirmed` — 受け取り確認された（→ 出品者への売上入金トリガー）
- `SellerRated` — 出品者が評価された
- `BalanceCharged` — 残高がチャージされた

#### 解説ポイント

- **購入価格のスナップショット**: 商品の価格は出品者が変更できるため、取引には購入時点の価格を記録する。Transaction が Item の価格を直接参照すると、後からの価格変更で不整合が起きる。
- **残高操作の整合性**: 購入時の「残高引き落とし」と取引完了時の「売上入金」は別トランザクション。結果整合性（イベント駆動）で実現するのが自然。
- **Item と Transaction を分ける理由**: 商品情報の管理（画像追加・説明変更）と取引の進行は独立した関心事。同一集約にすると不要なロック競合が発生する。

---

## 【問題 2】中級 — 病院の診察予約・診療システム

### 要件

> 病院の診察予約・診療記録システムを設計してください。
>
> - 患者は初診時に患者登録を行う。患者情報には氏名、生年月日、性別、連絡先、保険証情報がある。
> - 病院には複数の診療科（内科、外科、皮膚科など）があり、各診療科に医師が所属する。1人の医師は1つの診療科にのみ所属する。
> - 医師ごとに診察可能なスケジュール（曜日・時間枠）が設定されている。1つの時間枠は30分単位。
> - 患者は診療科と希望日時を指定して予約を取る。予約は医師の空き枠に対して行われる。
> - 同じ医師の同じ時間枠に複数の予約は入れられない。
> - 予約ステータスは「予約済み」→「受付済み」→「診察中」→「会計待ち」→「完了」と遷移する。「予約済み」からは「キャンセル」にも遷移できる。
> - 診察後、医師は診療記録を作成する。診療記録には主訴、診断名、処方（薬品名・用量・日数のリスト）、次回予約の有無が含まれる。
> - 会計は診療行為ごとの点数に基づいて計算される。保険適用で患者負担割合（1割〜3割）が変わる。
> - 処方箋は診療記録に基づいて発行される。処方箋には有効期限（発行日から4日間）がある。

**問い**: エンティティ、値オブジェクト、集約（境界の理由も）、ドメインイベント、ドメインサービスを抽出してください。

---

### 模範解答 2

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 患者 (Patient) | patientId | 氏名, 生年月日, 性別, 連絡先, 保険証情報 |
| 診療科 (Department) | departmentId | 診療科名 |
| 医師 (Doctor) | doctorId | 氏名, 所属診療科 |
| 予約 (Appointment) | appointmentId | 患者, 医師, 予約日時枠, ステータス |
| 診療記録 (MedicalRecord) | recordId | 予約(への参照), 患者, 医師, 主訴, 診断名, 処方リスト, 次回予約有無, 記録日時 |
| 処方箋 (Prescription) | prescriptionId | 診療記録(への参照), 患者, 処方内容リスト, 発行日, 有効期限 |
| 会計 (Billing) | billingId | 予約(への参照), 患者, 診療行為リスト, 合計点数, 患者負担額, 会計ステータス |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 保険証情報 (InsuranceInfo) | 保険者番号, 記号, 番号, 負担割合 | 属性の組で等価。変更時は丸ごと差し替え |
| 時間枠 (TimeSlot) | 日付, 開始時刻, 終了時刻(30分後) | 同じ日時なら等価 |
| 診察スケジュール (ConsultationSchedule) | 曜日ごとの時間枠リスト | 医師の定期スケジュール |
| 予約ステータス (AppointmentStatus) | 予約済み/受付済み/診察中/会計待ち/完了/キャンセル | 列挙型 |
| 処方明細 (PrescriptionItem) | 薬品名, 用量, 日数 | 処方の一行 |
| 診療行為 (MedicalProcedure) | 行為名, 点数 | 会計計算の明細行 |
| 診断名 (DiagnosisName) | 名称（ICD コードなど） | 標準化された値 |
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由 |
|---|---|---|
| **Patient** | Patient + InsuranceInfo | 患者基本情報は独立管理。保険証情報は患者と一体で変更される |
| **Doctor** | Doctor + ConsultationSchedule | スケジュールは医師に従属。医師とセットで整合性を保つ |
| **Department** | Department 単体 | 診療科マスタは独立 |
| **Appointment** | Appointment 単体 | 予約ステータスの遷移を管理。診療記録・会計とはライフサイクルが異なる |
| **MedicalRecord** | MedicalRecord + PrescriptionItem リスト | 診療記録と処方内容は同時に作成・確定される。一体で整合性を保つ |
| **Prescription** | Prescription 単体 | 処方箋は発行後に独立したライフサイクル（有効期限管理）を持つ |
| **Billing** | Billing + MedicalProcedure リスト | 会計と診療行為明細は一体。点数合計の整合性をこの中で保証 |

#### ドメインイベント

- `PatientRegistered` — 患者が登録された
- `AppointmentBooked` — 予約が作成された
- `AppointmentCancelled` — 予約がキャンセルされた
- `PatientCheckedIn` — 患者が受付した
- `ConsultationStarted` — 診察が開始された
- `ConsultationCompleted` — 診察が完了し診療記録が作成された（→ 会計作成・処方箋発行のトリガー）
- `PrescriptionIssued` — 処方箋が発行された
- `BillingCompleted` — 会計が完了した

#### ドメインサービス

| サービス | 責務 |
|---|---|
| 予約枠検索サービス (AvailableSlotFinder) | 診療科・希望日から、空き枠のある医師と時間枠の一覧を返す。Doctor の スケジュールと既存 Appointment を横断的に参照する。 |
| 会計計算サービス (BillingCalculationService) | 診療記録の内容から診療行為を判定し、点数を合算し、保険負担割合に応じた患者負担額を算出する。MedicalRecord と Patient（保険情報）をまたぐロジック。 |
| 処方箋発行サービス (PrescriptionIssuanceService) | 診療記録の処方内容に基づいて処方箋を生成する。有効期限（発行日+4日）を付与する。 |

#### 解説ポイント

- **MedicalRecord と Prescription を分ける理由**: 診療記録は医師が書く「記録」、処方箋は患者が薬局に持っていく「文書」。処方箋には有効期限という独自のライフサイクルがあるため、別集約にする。
- **Appointment を小さく保つ理由**: 予約は状態遷移が頻繁（受付→診察中→会計待ち…）で、更新頻度が高い。診療記録や会計を同じ集約に含めるとロック範囲が広がりすぎる。
- **予約の重複チェック**: 「同一医師×同一時間枠に複数予約不可」は AvailableSlotFinder で空き判定時にチェックする。予約作成時にもう一度楽観ロックで検証するのが堅実。

---

## 【問題 3】上級 — クラウドファンディングプラットフォーム

### 要件

> クラウドファンディングプラットフォームを設計してください。
>
> - プロジェクトオーナーはプロジェクトを作成する。プロジェクトにはタイトル、説明文、目標金額、募集期間（開始日・終了日）、カテゴリがある。
> - プロジェクトには複数のリターン（支援コース）を設定できる。各リターンには金額、説明、限定数（任意）がある。限定数が設定されている場合、その数を超える支援は受けられない。
> - プロジェクトのステータスは「下書き」→「審査中」→「募集中」→「成立」または「不成立」と遷移する。審査は運営が行う。
> - 募集期間が終了した時点で、目標金額以上の支援が集まっていれば「成立」、未満なら「不成立」となる（All-or-Nothing 方式）。
> - 支援者はリターンを選択して支援する。支援時にクレジットカードで決済が行われるが、実際の引き落としはプロジェクト成立時まで保留される（オーソリゼーション）。
> - プロジェクトが不成立の場合、すべての支援のオーソリゼーションが解放（キャンセル）される。
> - プロジェクトが成立した場合、全支援の引き落としが実行され、手数料 15% を差し引いた金額がオーナーに支払われる。
> - 支援者は募集期間中であれば支援をキャンセルできる。キャンセル時にオーソリゼーションは解放される。
> - プロジェクト成立後、オーナーは各支援者へのリターン発送状況を管理する。リターン発送ステータスは「未発送」→「発送済み」→「受領確認」と遷移する。
> - 支援者はプロジェクトにコメントを投稿でき、オーナーはコメントに返信できる（1階層のみ）。

**問い**: エンティティ、値オブジェクト、集約（境界の理由と注意点）、ドメインイベント、ドメインサービスを抽出してください。特に「成立/不成立の判定」「決済フロー」に関わる設計判断を説明してください。

---

### 模範解答 3

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| プロジェクトオーナー (ProjectOwner) | ownerId | 氏名, メールアドレス, 銀行口座情報 |
| プロジェクト (Project) | projectId | タイトル, 説明文, 目標金額, 募集期間, カテゴリ, ステータス, オーナー |
| リターン (Reward) | rewardId | 金額, 説明, 限定数, 残数 |
| 支援 (Pledge) | pledgeId | 支援者, プロジェクト, リターン, 支援金額, 決済ステータス |
| 支援者 (Backer) | backerId | 氏名, メールアドレス |
| リターン発送 (RewardFulfillment) | fulfillmentId | 支援(への参照), 発送ステータス |
| コメント (Comment) | commentId | 投稿者, プロジェクト, 本文, 親コメント(nullable) |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| 募集期間 (FundingPeriod) | 開始日, 終了日 | 期間を一体として扱う。「募集中か？」の判定ロジックを持てる |
| プロジェクトステータス (ProjectStatus) | 下書き/審査中/募集中/成立/不成立 | 列挙型 |
| 決済ステータス (PaymentStatus) | オーソリ済み/引落済み/解放済み/キャンセル | 列挙型 |
| 発送ステータス (FulfillmentStatus) | 未発送/発送済み/受領確認 | 列挙型 |
| 手数料率 (PlatformFeeRate) | 料率(15%) | ビジネスルールの明示化 |
| オーソリゼーション情報 (AuthorizationInfo) | 決済プロバイダのトランザクションID, オーソリ金額, 有効期限 | 外部システムとの連携情報 |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由・注意点 |
|---|---|---|
| **Project** | Project + Reward | リターンはプロジェクトに従属し、プロジェクトと一緒に作成・公開される。リターンの限定数管理もプロジェクト内の整合性として扱う。**注意**: 支援が集中した場合にリターンの残数更新が競合しうる。高トラフィックなら Reward を別集約に分離し楽観ロックで対応する選択肢もある。 |
| **Pledge** | Pledge + AuthorizationInfo | 支援は独立したライフサイクル（オーソリ→引落 or 解放）を持つ。プロジェクトの成否に応じて個別に状態遷移する。 |
| **RewardFulfillment** | RewardFulfillment 単体 | リターン発送はプロジェクト成立後に発生する別フェーズ。支援（Pledge）とはライフサイクルが異なる。 |
| **ProjectOwner** | ProjectOwner 単体 | オーナー情報は独立管理 |
| **Backer** | Backer 単体 | 支援者情報は独立管理 |
| **Comment** | Comment 単体 | コメントは独立したライフサイクル。返信は親コメントへの参照で表現 |

#### ドメインイベント

- `ProjectCreated` — プロジェクトが作成された
- `ProjectSubmittedForReview` — プロジェクトが審査に提出された
- `ProjectApproved` — 審査通過、募集開始
- `ProjectRejected` — 審査不通過
- `PledgeMade` — 支援が行われた（オーソリ完了）
- `PledgeCancelled` — 支援がキャンセルされた（オーソリ解放）
- `FundingGoalReached` — 支援総額が目標金額に到達した（通知目的。まだ成立確定ではない）
- `FundingPeriodEnded` — 募集期間が終了した（→ 成立/不成立判定のトリガー）
- `ProjectFunded` — プロジェクト成立（→ 全支援の引き落とし・オーナーへの支払いのトリガー）
- `ProjectNotFunded` — プロジェクト不成立（→ 全支援のオーソリ解放のトリガー）
- `PaymentCaptured` — 個別支援の引き落とし完了
- `PaymentReleased` — 個別支援のオーソリ解放完了
- `OwnerPaidOut` — オーナーへの支払い完了
- `RewardShipped` — リターンが発送された
- `RewardReceived` — リターンの受領が確認された

#### ドメインサービス

| サービス | 責務 |
|---|---|
| **プロジェクト成否判定サービス (FundingEvaluationService)** | 募集期間終了時に、支援総額と目標金額を比較し成立/不成立を判定する。Project（目標金額）と Pledge（支援金額の合計）を横断的に参照する。 |
| **決済オーケストレーションサービス (PaymentOrchestrationService)** | 成立時: 全 Pledge に対して引き落とし（Capture）を実行する。不成立時: 全 Pledge に対してオーソリ解放（Void）を実行する。外部決済プロバイダとの連携を抽象化する。**冪等性**の確保が重要。 |
| **オーナー精算サービス (OwnerSettlementService)** | 全引き落とし完了後、支援総額から手数料 15% を差し引いた金額を算出し、オーナーへの振込を実行する。 |
| **リターン残数管理サービス (RewardAvailabilityService)** | 支援時にリターンの残数を確認・減算する。Project 集約内で処理するか、高トラフィック時は楽観ロック+リトライで対応する。 |

#### 設計判断の解説

**1. 成立/不成立の判定について**

- 募集期間の終了はスケジューラが `FundingPeriodEnded` イベントを発行して検知する
- FundingEvaluationService が支援総額を集計し、`ProjectFunded` または `ProjectNotFunded` イベントを発行
- この判定は **1回だけ確実に実行される** 必要がある（冪等性 + 排他制御）

**2. 決済フローについて**

```
支援時:       Backer → PledgeMade → 外部決済: Authorize → AuthorizationInfo 保存
キャンセル時:  Backer → PledgeCancelled → 外部決済: Void
成立時:       ProjectFunded → 各Pledgeに対して Capture → PaymentCaptured
不成立時:     ProjectNotFunded → 各Pledgeに対して Void → PaymentReleased
精算:         全Capture完了 → OwnerSettlementService → OwnerPaidOut
```

- 決済は **結果整合性** で処理する。数百〜数千件の Pledge を1トランザクションで処理するのは非現実的
- 各 Pledge の Capture/Void は個別に実行し、失敗時はリトライキューで再処理
- AuthorizationInfo に外部の決済トランザクション ID を保持し、冪等な再実行を可能にする

**3. Reward の残数管理の注意点**

- 限定リターンに支援が集中すると、残数の更新が競合する（人気プロジェクトの「早い者勝ち」シナリオ）
- **案A**: Project 集約内で悲観ロック → 簡潔だがスループット低下
- **案B**: Reward を別集約に分離し楽観ロック + リトライ → 複雑だがスケーラブル
- **案C**: 残数を「在庫」として別の専用サービスで管理 → CQRS 的アプローチ
- 要件の規模感に応じて選択する。初期は案Aで十分なことが多い

---

## 総合チェックリスト

| # | チェック項目 |
|---|---|
| 1 | 要件中の主要な名詞をすべて検討したか |
| 2 | エンティティと値オブジェクトの区別は「一意に追跡する必要があるか」で判断したか |
| 3 | 集約の境界は「一緒に変更されるもの」で引けているか |
| 4 | 集約が大きすぎて更新競合のリスクはないか |
| 5 | ステータス遷移を列挙型の値オブジェクトで表現しているか |
| 6 | 時点で変わるデータ（価格など）のスナップショットを取っているか |
| 7 | 外部システム連携（決済など）の情報を値オブジェクトで保持しているか |
| 8 | 集約をまたぐロジックをドメインサービスに切り出しているか |
| 9 | 結果整合性が必要な箇所を特定し、ドメインイベントで繋いでいるか |
| 10 | 冪等性・リトライが必要な処理を意識しているか |
