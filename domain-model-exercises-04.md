# ドメインモデル抽出 — 練習問題と模範解答（第4回）

---

## 【問題 1】初級 — シェアサイクル（自転車シェアリング）

### 要件

> シェアサイクルサービスを設計してください。
>
> - 利用者はアプリでアカウントを作成し、クレジットカードを登録する。
> - 街中にステーション（自転車置き場）が複数あり、各ステーションには所在地とラック数（駐輪可能台数）がある。
> - 自転車にはそれぞれ固有の車体番号があり、現在どのステーションにあるかが記録されている。利用中の自転車はどのステーションにも属さない。
> - 利用者はステーションで自転車のQRコードを読み取って利用を開始する。ステーションに利用可能な自転車がない場合、利用開始できない。
> - 利用終了時、利用者は任意のステーションに自転車を返却する。返却先のステーションにラックの空きがない場合、返却できない。
> - 利用料金は「基本料金（最初の30分）＋ 超過料金（30分ごと）」で計算される。
> - 利用者は利用履歴を確認できる。各履歴には出発ステーション、到着ステーション、利用時間、料金が記録される。
> - 自転車には「利用可能」「利用中」「故障中」のステータスがある。故障中の自転車は利用開始できない。

**問い**: エンティティ、値オブジェクト、集約、ドメインイベントを抽出してください。

---

### 模範解答 1

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 利用者 (User) | userId | 氏名, メールアドレス, クレジットカード情報 |
| ステーション (Station) | stationId | ステーション名, 所在地, ラック数 |
| 自転車 (Bicycle) | bicycleId (車体番号) | ステータス, 現在のステーション(nullable) |
| 利用 (Ride) | rideId | 利用者, 自転車, 出発ステーション, 到着ステーション, 開始時刻, 終了時刻, 料金 |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 所在地 (Location) | 緯度, 経度, 住所 | 同じ座標なら等価 |
| 自転車ステータス (BicycleStatus) | 利用可能/利用中/故障中 | 列挙型 |
| 料金 (RideFee) | 基本料金, 超過料金, 合計金額 | 計算結果の値。内訳を保持 |
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| クレジットカード情報 (PaymentMethod) | トークン化されたカード情報 | 外部決済連携用 |
| 利用時間 (RideDuration) | 開始時刻, 終了時刻, 経過分数 | 時間の区間を表す値 |

#### 集約

| 集約ルート | 含まれるもの | 整合性のルール |
|---|---|---|
| **Station** | Station 単体 | ラック数と現在の駐輪台数の整合性。空きラックの判定 |
| **Bicycle** | Bicycle 単体 | ステータスの遷移ルール。利用可能な自転車のみ貸し出せる |
| **Ride** | Ride + RideFee | 利用の記録。開始→終了のライフサイクル、料金計算結果の保持 |
| **User** | User + PaymentMethod | 利用者情報と決済手段の管理 |

#### ドメインイベント

- `RideStarted` — 利用が開始された（→ 自転車ステータスを「利用中」に、ステーションの駐輪台数を減算）
- `RideEnded` — 利用が終了された（→ 自転車ステータスを「利用可能」に、返却先ステーションの駐輪台数を加算、料金計算）
- `BicycleReportedBroken` — 自転車が故障報告された
- `BicycleRepaired` — 自転車が修理完了した

#### 解説ポイント

- **Station に Bicycle を含めない理由**: 自転車は利用中にステーションから離れる。ステーションと自転車のライフサイクルは独立している。「どのステーションにあるか」は Bicycle 側が参照として保持する。
- **Ride を独立集約にする理由**: 利用記録は作成後に変更されることが少ない（終了時に一度だけ更新）。利用者や自転車とは独立して履歴として蓄積される。
- **ステーションの空き判定**: Station がラック数を保持し、現在の駐輪台数（= そのステーションに紐づく利用可能な Bicycle の数）と比較する。この駐輪台数をどう管理するかは設計判断。Station に「現在台数」を持たせるか、都度 Bicycle を数えるか。高頻度アクセスなら前者（非正規化）が実用的。

---

## 【問題 2】中級 — ワークフロー承認システム

### 要件

> 企業内のワークフロー承認システムを設計してください。
>
> - 社員は各種の申請を提出できる。申請種別には「経費精算」「休暇申請」「購買申請」などがある。
> - 申請種別ごとに承認ルート（承認者の順序）が定義されている。例えば経費精算は「直属上司 → 部門長 → 経理部」の3段階。
> - 承認ルートは金額や条件によって分岐する。経費精算の場合、10万円以下は「直属上司のみ」、10万円超は「直属上司 → 部門長」、50万円超は「直属上司 → 部門長 → 経理部」。
> - 各承認ステップで、承認者は「承認」「差し戻し」「却下」のいずれかを選択する。
> - 差し戻しの場合、申請者は内容を修正して再提出できる。再提出すると承認ルートの最初からやり直す。
> - 却下されると申請は終了する。
> - 承認者が不在（休暇中など）の場合、事前に設定した代理承認者が承認できる。
> - 全ステップの承認が完了すると申請は「承認完了」となる。
> - 各承認ステップにはSLA（期限）がある。期限を過ぎるとリマインダーが送られ、さらに超過すると自動エスカレーション（上位者に承認依頼が移る）される。
> - 申請と承認の履歴（誰がいつ何をしたか）は全て記録され、監査証跡として利用される。

**問い**: エンティティ、値オブジェクト、集約（境界の理由も）、ドメインイベント、ドメインサービスを抽出してください。

---

### 模範解答 2

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 社員 (Employee) | employeeId | 氏名, 部署, 役職, 代理承認者 |
| 申請 (Application) | applicationId | 申請者, 申請種別, 申請内容, 申請ステータス, 現在の承認ステップ |
| 承認ステップ (ApprovalStep) | stepId | 承認順序, 承認者（役割ベース）, 実際の承認者, 判断, 判断日時, SLA期限, コメント |
| 承認ルートテンプレート (ApprovalRouteTemplate) | templateId | 申請種別, 条件（金額範囲等）, ステップ定義リスト |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 申請種別 (ApplicationType) | 経費精算/休暇申請/購買申請 等 | 列挙型またはコード値 |
| 申請ステータス (ApplicationStatus) | 下書き/申請中/差し戻し/承認完了/却下 | 列挙型 |
| 承認判断 (ApprovalDecision) | 承認/差し戻し/却下 | 列挙型 |
| ステップ定義 (StepDefinition) | 承認順序, 承認者の役割, SLA日数 | テンプレート内の一行 |
| 条件 (RouteCondition) | 条件種別(金額範囲等), 閾値 | ルート分岐の判定条件 |
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| 監査エントリ (AuditEntry) | 操作者, 操作種別, 日時, 変更内容 | 操作履歴の一行 |
| 経費精算内容 (ExpenseDetail) | 日付, 項目, 金額, 摘要 | 申請種別固有の内容（例） |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由 |
|---|---|---|
| **Application** | Application + ApprovalStep リスト + AuditEntry リスト | 申請と承認ステップは一体のライフサイクル。「どのステップまで進んだか」「全ステップ完了で承認完了」は申請の中で整合性を保つ必要がある。監査エントリも申請に紐づく不変の記録。 |
| **ApprovalRouteTemplate** | ApprovalRouteTemplate + StepDefinition + RouteCondition | 承認ルートのマスタ定義。申請作成時に参照されるが、申請とは独立して管理される。テンプレートの変更が既存の進行中の申請に影響してはならない。 |
| **Employee** | Employee 単体 | 社員情報・代理承認者設定は独立管理 |

#### ドメインイベント

- `ApplicationSubmitted` — 申請が提出された（→ 承認ルート生成、最初の承認者への通知）
- `ApplicationResubmitted` — 差し戻し後に再提出された（→ 承認ルートをリセットして最初から）
- `StepApproved` — 承認ステップが承認された（→ 次のステップへ進行、または全完了判定）
- `StepRejected` — 承認ステップが却下された（→ 申請終了）
- `StepSentBack` — 承認ステップが差し戻された（→ 申請者への通知）
- `ApplicationApproved` — 全ステップ承認完了
- `ApplicationRejected` — 申請が却下された
- `SLAReminderSent` — SLA期限のリマインダーが送信された
- `StepEscalated` — SLA超過でエスカレーションされた（→ 上位者に承認依頼が移る）
- `ProxyApprovalUsed` — 代理承認者が承認を実施した

#### ドメインサービス

| サービス | 責務 |
|---|---|
| **承認ルート決定サービス (ApprovalRouteResolver)** | 申請種別と申請内容（金額等）から適切な ApprovalRouteTemplate を選択し、具体的な承認ステップを生成する。条件分岐ロジックを担う。テンプレートのスナップショットを取り、申請に紐づける。 |
| **承認者解決サービス (ApproverResolver)** | ステップ定義の「役割」（直属上司、部門長等）から、実際の承認者（社員）を特定する。代理承認者の判定もここで行う。Employee の組織情報と休暇情報を参照する。 |
| **SLA監視サービス (SLAMonitoringService)** | 各承認ステップの期限を監視し、リマインダー送信やエスカレーションをトリガーする。スケジューラと連携。 |
| **エスカレーションサービス (EscalationService)** | SLA超過時に上位の承認者を特定し、承認ステップの担当を移管する。ApproverResolver と連携。 |

#### 解説ポイント

- **承認ルートのスナップショット**: 申請提出時にテンプレートから具体的な ApprovalStep を生成して Application 集約内にコピーする。テンプレートが後から変更されても、進行中の申請の承認ルートは変わらない。これは注文時に商品価格をスナップショットするのと同じ考え方。
- **Application 集約が大きくなるリスク**: ApprovalStep と AuditEntry を含むため、承認ステップが多段階でコメントが長い場合は集約が肥大化する。ただし、1つの申請に対する承認ステップ数は通常10未満であり、実用上は問題になりにくい。
- **役割ベース vs 個人指定の承認者**: ステップ定義では「直属上司」「部門長」という役割で指定し、実行時に ApproverResolver が具体的な社員に解決する。これにより、人事異動があってもテンプレートの変更が不要。
- **差し戻し時のルートリセット**: 再提出すると承認ルートの最初からやり直す。これは Application 集約内で ApprovalStep リストをクリアし、承認ルート決定サービスで再生成する。修正内容によって金額が変わればルート自体が変わる可能性もある。

---

## 【問題 3】上級 — マルチテナント型プロジェクト管理ツール

### 要件

> チーム向けのプロジェクト管理ツール（Jira のようなもの）を設計してください。
>
> - 組織（ワークスペース）を作成でき、複数のメンバーが参加する。メンバーにはロール（オーナー/管理者/メンバー/ゲスト）がある。
> - ワークスペース内に複数のプロジェクトを作成できる。プロジェクトにはプロジェクトキー（例: "PROJ"）があり、チケット番号のプレフィクスになる。
> - プロジェクト内にチケット（課題）を作成できる。チケットには以下の情報がある:
>   - チケット番号（例: PROJ-123。プロジェクトキー + 連番で自動採番）
>   - タイトル、説明、チケット種別（タスク/バグ/ストーリー/エピック）
>   - ステータス（カスタマイズ可能。デフォルトは「未着手」→「進行中」→「レビュー中」→「完了」）
>   - 優先度（最高/高/中/低/最低）
>   - 担当者（1名）、報告者（1名）
>   - 見積もりポイント、期限
> - プロジェクトごとにカスタムのステータスワークフローを定義できる。ワークフローでは「どのステータスからどのステータスに遷移できるか」を定義する。
> - エピックは他のチケット（タスク/バグ/ストーリー）を子チケットとして持つことができる。エピックの進捗は子チケットの完了率で自動算出される。
> - チケットにはコメントを投稿でき、他のメンバーをメンション（@mention）できる。メンションされたメンバーには通知が送られる。
> - チケットには添付ファイルを追加できる（ファイル名、サイズ、アップロード者、URL）。
> - チケット間に「ブロック」「ブロックされている」「関連」の依存関係を設定できる。
> - チケットの全変更履歴が記録される（フィールド名、変更前の値、変更後の値、変更者、日時）。
> - スプリント（期間を区切ったイテレーション）を作成し、チケットをスプリントに割り当てられる。スプリントには名前、開始日、終了日がある。スプリントのステータスは「計画中」→「進行中」→「完了」。
> - ラベル（タグ）をチケットに複数付与できる。ラベルはプロジェクト内で自由に作成できる。

**問い**: エンティティ、値オブジェクト、集約（境界の理由と、特に「チケットの集約境界をどこに引くか」の判断）、ドメインイベント、ドメインサービスを抽出してください。

---

### 模範解答 3

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| ワークスペース (Workspace) | workspaceId | 名称 |
| ワークスペースメンバー (WorkspaceMember) | memberId | ユーザー, ロール |
| ユーザー (User) | userId | 氏名, メールアドレス |
| プロジェクト (Project) | projectId | プロジェクト名, プロジェクトキー, ワークスペース |
| チケット (Ticket) | ticketId | チケット番号, タイトル, 説明, 種別, ステータス, 優先度, 担当者, 報告者, 見積もりポイント, 期限, 親エピック(nullable), スプリント(nullable) |
| コメント (Comment) | commentId | チケット, 投稿者, 本文, メンションリスト |
| ワークフロー (Workflow) | workflowId | プロジェクト, ステータス定義リスト, 遷移ルール |
| スプリント (Sprint) | sprintId | プロジェクト, 名前, 開始日, 終了日, ステータス |
| ラベル (Label) | labelId | プロジェクト, 名前, 色 |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| チケット番号 (TicketNumber) | プロジェクトキー + 連番 | 一意識別のための値。フォーマットルールを持つ |
| チケット種別 (TicketType) | タスク/バグ/ストーリー/エピック | 列挙型 |
| 優先度 (Priority) | 最高/高/中/低/最低 | 列挙型 |
| ステータス (Status) | 名前, カテゴリ(未開始/進行中/完了) | カスタム定義されるが、各値はIDで区別不要 |
| 遷移ルール (TransitionRule) | 遷移元ステータス, 遷移先ステータス | ワークフロー内の一行 |
| 添付ファイル (Attachment) | ファイル名, サイズ, URL, アップロード者, 日時 | チケットに付随する値。独自ライフサイクル不要 |
| 変更履歴エントリ (ChangeLogEntry) | フィールド名, 変更前の値, 変更後の値, 変更者, 日時 | チケットの変更記録の一行。追記のみ |
| チケット依存関係 (TicketDependency) | 関係種別(ブロック/ブロックされている/関連), 相手チケットID | 依存関係の定義 |
| メンション (Mention) | 対象ユーザーID | コメント内の参照 |
| スプリントステータス (SprintStatus) | 計画中/進行中/完了 | 列挙型 |
| 見積もりポイント (StoryPoint) | 数値 | バリデーション付きの値（フィボナッチ数列等） |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由 |
|---|---|---|
| **Workspace** | Workspace + WorkspaceMember | メンバーの追加・削除・ロール変更はワークスペースの整合性として管理。メンバー数が大規模（数千人）になる場合は WorkspaceMember を別集約に分離する選択もある。 |
| **Project** | Project 単体 | プロジェクトの基本情報管理。チケット番号の連番管理はここで行う（採番カウンタ保持）。 |
| **Ticket** | Ticket + Attachment + ChangeLogEntry + TicketDependency | **チケットが中心的な集約**。添付ファイル・変更履歴・依存関係はチケットに従属する。これらはチケットなしに存在しない。 |
| **Comment** | Comment + Mention | コメントはチケットに紐づくが、独立した集約にする。理由: ①コメントの追加は高頻度で発生し、チケット集約をロックしたくない。②コメントの追加・編集でチケット本体の整合性に影響しない。 |
| **Workflow** | Workflow + ステータス定義 + TransitionRule | ワークフローはプロジェクト単位の設定。チケットのステータス遷移時に参照されるが、チケットとは独立して定義・変更される。 |
| **Sprint** | Sprint 単体 | スプリントはチケットとは独立したライフサイクル（計画→進行→完了）。チケットとは参照関係。 |
| **Label** | Label 単体 | ラベルはプロジェクト内の共有リソース。チケットとは多対多の参照関係。 |
| **User** | User 単体 | ユーザー情報は独立管理。複数ワークスペースに参加可能。 |

#### 「チケットの集約境界をどこに引くか」の判断

チケットには多くの関連要素があるため、何を含め何を外すかが設計の核心になる。

**含めるもの（Ticket 集約内）:**

| 要素 | 理由 |
|---|---|
| Attachment | チケットの一部。添付ファイルの追加・削除時にチケットの変更履歴にも記録したい |
| ChangeLogEntry | チケットの変更記録そのもの。追記のみで競合しにくい |
| TicketDependency | チケットの属性の一部。依存関係はチケットを通じてのみ操作される |

**含めないもの（別集約）:**

| 要素 | 理由 |
|---|---|
| Comment | 追加頻度が高い。チケット本体と独立して操作可能。チケットの不変条件に影響しない |
| Sprint | 独立したライフサイクル。チケットはスプリントへの参照（sprintId）を持つだけ |
| Label | 共有リソース。チケットとは多対多。ラベルの名前変更がチケット集約に波及すべきでない |

**トレードオフ:**
- Attachment を含めると、大量の添付ファイルがある場合にチケット集約のロード時間が増える。メタデータ（ファイル名・URL等）のみ集約内に持ち、実ファイルは外部ストレージに置くことで軽量に保つ。
- ChangeLogEntry は蓄積され続ける。実装上は遅延ロード（必要時のみ取得）にするか、一定期間でアーカイブする運用も検討する。

#### ドメインイベント

- `WorkspaceCreated` — ワークスペースが作成された
- `MemberJoined` — メンバーが参加した
- `MemberRoleChanged` — メンバーのロールが変更された
- `ProjectCreated` — プロジェクトが作成された
- `TicketCreated` — チケットが作成された
- `TicketStatusChanged` — チケットのステータスが変更された
- `TicketAssigned` — チケットの担当者が変更された
- `TicketMovedToSprint` — チケットがスプリントに割り当てられた
- `TicketLinked` — チケット間に依存関係が設定された
- `CommentPosted` — コメントが投稿された（→ メンション通知トリガー）
- `AttachmentAdded` — 添付ファイルが追加された
- `SprintStarted` — スプリントが開始された
- `SprintCompleted` — スプリントが完了した
- `WorkflowUpdated` — ワークフローが変更された
- `EpicProgressUpdated` — エピックの進捗が更新された（子チケットのステータス変更時に算出）

#### ドメインサービス

| サービス | 責務 |
|---|---|
| **チケット採番サービス (TicketNumberingService)** | プロジェクトキーと連番からチケット番号を生成する。連番の一意性を保証する。Project 集約の採番カウンタを使用し、競合時は楽観ロック + リトライで対応。 |
| **ステータス遷移検証サービス (StatusTransitionValidator)** | チケットのステータス変更時に、Workflow の遷移ルールに従った有効な遷移かを検証する。Ticket 集約と Workflow 集約をまたぐ。 |
| **エピック進捗計算サービス (EpicProgressCalculator)** | エピックの子チケットの完了状況を集計し、進捗率を算出する。子チケットのステータス変更イベントをトリガーに非同期で実行。 |
| **メンション通知サービス (MentionNotificationService)** | コメント投稿時にメンションを解析し、該当ユーザーに通知を送信する。Comment の作成イベントを購読。 |
| **ブロック検出サービス (BlockageDetectionService)** | チケットのステータスを「完了」に変更しようとした際、そのチケットが他のチケットをブロックしている場合に警告する（またはブロック先への通知を送る）。 |

#### 解説ポイント

- **ワークフローのカスタマイズと整合性**: Workflow はプロジェクト設定として独立集約にする。チケットのステータス遷移時にワークフローを参照するが、ワークフローの変更が進行中のチケットに即座に影響する点は要注意。「進行中」のチケットのステータスが新ワークフローで孤立しないよう、ワークフロー変更時の検証が必要。
- **エピックと子チケットの関係**: エピック自体もチケット（種別がエピック）。親子関係はチケットの属性（parentEpicId）で表現する。エピックの進捗は子チケットの完了率から算出するが、これを同期的にやるとエピック集約と子チケット集約の間に強い結合ができる。イベント駆動で非同期に計算するのが適切。
- **チケット番号の採番**: 連番の一意性は重要な不変条件。Project 集約にカウンタを持たせ、チケット作成時にインクリメントする設計が基本。高頻度でチケットが作成されるプロジェクトでは楽観ロックの競合が起きるが、リトライで対応可能な頻度であることが多い。

---

## 総合チェックリスト（第4回追加項目含む）

| # | チェック項目 |
|---|---|
| 1 | 要件中の主要な名詞をすべて検討したか |
| 2 | エンティティと値オブジェクトの区別は「一意に追跡する必要があるか」で判断したか |
| 3 | 集約の境界は「一緒に変更されるもの」で引けているか |
| 4 | 集約が大きすぎて更新競合のリスクはないか |
| 5 | ステータス遷移を列挙型の値オブジェクトで表現しているか |
| 6 | 時点で変わるデータのスナップショットを取っているか |
| 7 | 外部システム連携の情報を値オブジェクトで保持しているか |
| 8 | 集約をまたぐロジックをドメインサービスに切り出しているか |
| 9 | 結果整合性が必要な箇所を特定し、ドメインイベントで繋いでいるか |
| 10 | 冪等性・リトライが必要な処理を意識しているか |
| 11 | 時間に依存する処理の実現方法を考えたか |
| 12 | バッチ処理 vs リアルタイム処理の判断は適切か |
| 13 | マスタデータとトランザクションデータを区別しているか |
| 14 | 状態遷移が複数段階にまたがる場合のオーケストレーションを設計したか |
| 15 | **集約内の要素が肥大化するリスク**（履歴、コメント等の蓄積）を検討したか |
| 16 | **カスタマイズ可能なルール**（ワークフロー等）と実データの整合性を考えたか |
| 17 | **多対多の関係**を参照（ID保持）で表現しているか |
| 18 | **採番・連番の一意性保証**の方法を考えたか |
