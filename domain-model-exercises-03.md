# ドメインモデル抽出 — 練習問題と模範解答（第3回）

---

## 【問題 1】初級 — フードデリバリーサービス

### 要件

> フードデリバリーサービスを設計してください。
>
> - 飲食店はメニューを登録できる。各メニューには商品名、説明、価格、カテゴリ（メイン/サイド/ドリンク等）がある。
> - 飲食店は営業時間を設定でき、営業時間外は注文を受け付けない。
> - 飲食店はメニューごとに「売り切れ」を設定できる。売り切れの商品は注文できない。
> - 注文者はエリア内の飲食店を検索し、メニューを選んで注文する。1回の注文は1店舗に対してのみ。
> - 注文には配達先住所が必要。配達先住所は「氏名・電話番号・郵便番号・住所・建物名・部屋番号」で構成される。
> - 注文金額は「商品合計 + 配達手数料」で計算される。配達手数料は飲食店と配達先の距離に応じて変動する。
> - 注文ステータスは「注文受付」→「調理中」→「配達員待ち」→「配達中」→「配達完了」と遷移する。飲食店は「注文受付」の段階で注文を拒否できる。
> - 配達員はシステムに登録されており、「配達員待ち」の注文に対して配達員が割り当てられる。
> - 注文者は配達完了後に、飲食店と配達員それぞれを5段階で評価できる。

**問い**: エンティティ、値オブジェクト、集約、ドメインイベントを抽出してください。

---

### 模範解答 1

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 飲食店 (Restaurant) | restaurantId | 店名, エリア, 営業時間 |
| メニュー (MenuItem) | menuItemId | 商品名, 説明, 価格, カテゴリ, 売り切れフラグ |
| 注文者 (Customer) | customerId | 氏名, メールアドレス, 電話番号 |
| 注文 (Order) | orderId | 注文者, 飲食店, 注文明細リスト, 配達先住所, 配達手数料, 注文ステータス, 配達員 |
| 配達員 (DeliveryDriver) | driverId | 氏名, 電話番号, 稼働ステータス |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 配達先住所 (DeliveryAddress) | 氏名, 電話番号, 郵便番号, 住所, 建物名, 部屋番号 | 属性の組で等価 |
| 営業時間 (BusinessHours) | 曜日ごとの開始時刻・終了時刻 | 飲食店の営業ルール |
| 注文明細 (OrderLine) | メニュー(への参照), 商品名, 単価, 数量 | 注文時点のスナップショット |
| 注文ステータス (OrderStatus) | 注文受付/調理中/配達員待ち/配達中/配達完了/拒否 | 列挙型 |
| メニューカテゴリ (MenuCategory) | メイン/サイド/ドリンク等 | 列挙型 |
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| 配達手数料 (DeliveryFee) | 金額, 距離 | 計算結果の値 |
| 評価 (Review) | 対象種別(飲食店/配達員), 星評価(1〜5), コメント | 注文に付随する値。独立したライフサイクル不要なら値オブジェクトで十分 |

#### 集約

| 集約ルート | 含まれるもの | 整合性のルール |
|---|---|---|
| **Restaurant** | Restaurant + MenuItem + BusinessHours | メニューは飲食店に従属。売り切れ状態の管理、営業時間の判定はこの集約内 |
| **Order** | Order + OrderLine + DeliveryAddress + 評価 | 注文の整合性（ステータス遷移、金額計算）を管理。評価は注文に紐づく付属情報 |
| **Customer** | Customer 単体 | 注文者情報の独立管理 |
| **DeliveryDriver** | DeliveryDriver 単体 | 配達員の稼働状態管理 |

#### ドメインイベント

- `OrderPlaced` — 注文が作成された（→ 飲食店への通知トリガー）
- `OrderAccepted` — 飲食店が注文を受け付けた
- `OrderRejected` — 飲食店が注文を拒否した
- `CookingCompleted` — 調理が完了した（→ 配達員割当のトリガー）
- `DriverAssigned` — 配達員が割り当てられた
- `DeliveryStarted` — 配達が開始された
- `DeliveryCompleted` — 配達が完了した
- `OrderReviewed` — 評価が投稿された

#### 解説ポイント

- **OrderLine にスナップショットを取る理由**: メニューの価格や名称は飲食店が随時変更できる。注文確定時の情報を保持しないと、過去の注文内容が書き変わってしまう。
- **評価をエンティティではなく値オブジェクトにした判断**: この要件では評価の編集・削除・一覧検索などのライフサイクルが明示されていない。注文に対して「あるかないか」の付属情報として扱える。要件が拡張されたらエンティティに昇格させる。
- **Restaurant 集約に MenuItem を含める判断**: メニューは飲食店の一部であり、単独では意味を持たない。ただしメニュー数が非常に多くなる場合（数百品目）、Restaurant 集約が肥大化する。その場合は MenuItem を別集約に分離する選択もある。

---

## 【問題 2】中級 — イベントチケット販売システム

### 要件

> イベントチケットの販売システムを設計してください。
>
> - 主催者はイベントを作成する。イベントにはタイトル、説明、開催日時、会場、カテゴリ（音楽/スポーツ/演劇等）がある。
> - イベントには複数のチケット種別を設定できる（例: VIP席、一般席、立見）。各チケット種別には価格、販売枚数上限、販売開始日時がある。
> - チケットの販売開始前はチケットを購入できない。販売枚数が上限に達した種別は「売り切れ」となる。
> - 購入者はチケット種別と枚数を選んで購入する。1回の購入で同一イベントの複数種別を混在して購入できる。
> - 購入時に10分間の「仮押さえ」が行われる。10分以内に決済が完了しないと仮押さえは解放される。
> - 決済完了後、購入ごとに一意の注文番号が発行される。各チケットにはQRコード（一意の文字列）が付与される。
> - 購入者は購入後にチケットを他の人に譲渡（名義変更）できる。譲渡は1チケットにつき最大2回まで。
> - イベントが中止になった場合、該当イベントの全チケットに対して自動で全額返金処理が行われる。
> - 入場時にQRコードをスキャンして入場を記録する。同じQRコードでの二重入場はできない。

**問い**: エンティティ、値オブジェクト、集約（境界の理由も）、ドメインイベント、ドメインサービスを抽出してください。

---

### 模範解答 2

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| 主催者 (Organizer) | organizerId | 氏名, 連絡先 |
| イベント (Event) | eventId | タイトル, 説明, 開催日時, 会場, カテゴリ, ステータス |
| チケット種別 (TicketType) | ticketTypeId | 種別名, 価格, 販売枚数上限, 残数, 販売開始日時 |
| 注文 (Order) | orderId | 購入者, 注文番号, 注文明細, 決済ステータス, 仮押さえ期限 |
| チケット (Ticket) | ticketId | チケット種別, QRコード, 現在の所有者, 譲渡回数, 入場済みフラグ |
| 購入者 (Buyer) | buyerId | 氏名, メールアドレス |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 会場 (Venue) | 会場名, 住所, キャパシティ | 同じ属性なら等価（※ 会場管理が独立機能になるならエンティティに昇格） |
| 注文明細 (OrderLine) | チケット種別(への参照), 種別名, 単価, 枚数 | 購入時のスナップショット |
| QRコード (QRCode) | 一意の文字列 | 識別トークンだが、チケットの属性として従属する値 |
| 決済ステータス (PaymentStatus) | 仮押さえ中/決済完了/返金済み/期限切れ | 列挙型 |
| イベントステータス (EventStatus) | 準備中/販売中/開催済み/中止 | 列挙型 |
| イベントカテゴリ (EventCategory) | 音楽/スポーツ/演劇等 | 列挙型 |
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| 譲渡履歴 (TransferRecord) | 譲渡元, 譲渡先, 譲渡日時 | チケットに付随する記録 |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由 |
|---|---|---|
| **Event** | Event + TicketType | チケット種別はイベントに従属。販売枚数上限・残数の管理はイベント内の整合性。**注意**: 人気イベントで TicketType の残数更新が競合する場合、TicketType を別集約に分離して楽観ロックで対応する選択肢がある。 |
| **Order** | Order + OrderLine | 注文の整合性（仮押さえ期限、決済ステータス遷移）を管理。注文明細は注文と一体で確定される。 |
| **Ticket** | Ticket + TransferRecord | チケットは発行後に独立したライフサイクル（譲渡・入場）を持つ。Order とは別集約にすることで、譲渡や入場処理が注文に影響しない。 |
| **Organizer** | Organizer 単体 | 主催者情報は独立管理 |
| **Buyer** | Buyer 単体 | 購入者情報は独立管理 |

#### ドメインイベント

- `EventCreated` — イベントが作成された
- `TicketSalesStarted` — チケット販売が開始された
- `SeatsReserved` — 仮押さえが行われた（→ 10分タイマー開始）
- `ReservationExpired` — 仮押さえが期限切れになった（→ 残数復元）
- `PaymentCompleted` — 決済が完了した（→ チケット発行トリガー）
- `TicketsIssued` — チケット（QRコード付き）が発行された
- `TicketTransferred` — チケットが譲渡された
- `EventCancelled` — イベントが中止された（→ 全チケット返金トリガー）
- `RefundProcessed` — 返金処理が完了した
- `EntryRecorded` — 入場が記録された
- `TicketTypeSoldOut` — チケット種別が売り切れた

#### ドメインサービス

| サービス | 責務 |
|---|---|
| 仮押さえサービス (SeatReservationService) | 購入リクエストを受け、TicketType の残数を確認・減算し、Order を仮押さえ状態で作成する。Event 集約と Order 集約をまたぐ処理。 |
| チケット発行サービス (TicketIssuanceService) | 決済完了後、注文明細に基づいて Ticket エンティティ（QRコード付き）を生成する。Order 集約と Ticket 集約をまたぐ。 |
| 返金オーケストレーションサービス (RefundOrchestrationService) | イベント中止時、該当イベントの全注文に対して返金処理を実行する。Event・Order・外部決済を横断する。冪等性の確保が重要。 |
| 入場検証サービス (EntryValidationService) | QRコードの有効性確認（存在するか、入場済みでないか、イベントが正しいか）を行い、入場を記録する。 |

#### 解説ポイント

- **Ticket を Order から分離する理由**: チケットは購入後に「譲渡」「入場」という注文とは無関係なライフサイクルを持つ。Order に含めると、譲渡のたびに Order 集約をロックすることになり不自然。
- **仮押さえの設計**: 「残数の減算（Event集約）」と「注文の作成（Order集約）」が別集約にまたがる。これを1トランザクションで行うか、Sagaパターンで補償するかは規模に応じた判断。小規模なら同一トランザクションでも許容される。
- **譲渡回数の制限**: 「最大2回」は Ticket 集約内の不変条件。TransferRecord のリスト長で判定できる。

---

## 【問題 3】上級 — SaaS サブスクリプション管理プラットフォーム

### 要件

> BtoB SaaS のサブスクリプション管理・課金システムを設計してください。
>
> - SaaS ベンダーは複数のプランを提供する。各プランには名称、月額料金、年額料金、機能リスト、ユーザー数上限がある。プランは「フリー」「スタンダード」「プロ」「エンタープライズ」の4段階。
> - 顧客企業（テナント）はサインアップし、初期はフリープランが適用される。テナントには企業名、請求先住所、請求先メールアドレスがある。
> - テナントにはオーナー（1名）と複数のメンバーが所属する。オーナーはメンバーの招待・削除、プランの変更・解約ができる。メンバーにはロール（管理者/一般）が割り当てられる。
> - テナントはプランをアップグレードまたはダウングレードできる。
>   - アップグレード: 即時適用。残り日数分の差額が日割り計算される。
>   - ダウングレード: 現在の請求期間の終了時に適用（即時ではない）。ダウングレード先のユーザー数上限を超えている場合は、先にメンバーを削減する必要がある。
> - 課金は月次または年次の自動更新。請求書が生成され、登録済みのクレジットカードに自動課金される。
> - 課金に失敗した場合、3日間隔で最大3回リトライする。3回失敗すると「支払い滞納」状態になり、サービスが制限される。
> - 滞納から30日経過すると、テナントは「停止」状態になりアクセスできなくなる。停止後90日でデータが削除される。
> - テナントは解約できる。解約は現在の請求期間の終了時に有効になる。解約後もデータは30日間保持される。
> - 利用量に応じた従量課金もある（例: API コール数、ストレージ使用量）。従量課金は月末に集計され、翌月の請求に合算される。
> - 請求書には、基本料金、従量課金の内訳、日割り調整額、税額が記載される。

**問い**: エンティティ、値オブジェクト、集約（境界の理由と設計上の注意点）、ドメインイベント、ドメインサービスを抽出してください。特に「プラン変更時の日割り計算」「課金失敗時のリトライと状態遷移」「従量課金の集計」の設計判断を説明してください。

---

### 模範解答 3

#### エンティティ

| エンティティ | 識別子 | 主な属性・関連 |
|---|---|---|
| プラン (Plan) | planId | 名称, 月額料金, 年額料金, 機能リスト, ユーザー数上限 |
| テナント (Tenant) | tenantId | 企業名, 請求先住所, 請求先メール, テナントステータス |
| メンバーシップ (Membership) | membershipId | テナント, ユーザー, ロール, オーナーフラグ |
| ユーザー (User) | userId | 氏名, メールアドレス |
| サブスクリプション (Subscription) | subscriptionId | テナント, 現在のプラン, 課金サイクル(月/年), 開始日, 次回更新日, ステータス, 予約されたダウングレード先プラン |
| 請求書 (Invoice) | invoiceId | テナント, 請求期間, 明細リスト, 合計金額, 税額, 請求ステータス |
| 決済試行 (PaymentAttempt) | attemptId | 請求書, 試行日時, 結果, 失敗理由 |
| 利用量レコード (UsageRecord) | recordId | テナント, メトリクス種別, 期間, 集計値 |

#### 値オブジェクト

| 値オブジェクト | 構成要素 | 理由 |
|---|---|---|
| 金額 (Money) | 数値, 通貨 | 汎用値オブジェクト |
| 請求先住所 (BillingAddress) | 企業名, 郵便番号, 住所 | 属性の組で等価 |
| 課金サイクル (BillingCycle) | 月次/年次 | 列挙型 |
| テナントステータス (TenantStatus) | アクティブ/支払い滞納/制限中/停止/解約予約中/解約済み | 列挙型 |
| サブスクリプションステータス (SubscriptionStatus) | アクティブ/ダウングレード予約中/解約予約中/解約済み | 列挙型 |
| 請求ステータス (InvoiceStatus) | 下書き/確定/支払済み/滞納/取消 | 列挙型 |
| 請求明細 (InvoiceLineItem) | 項目名, 種別(基本料金/従量/日割り調整/税), 金額, 数量, 単価 | 請求書の一行 |
| ロール (Role) | 管理者/一般 | 列挙型 |
| 機能リスト (FeatureSet) | 機能名のリスト | プランに紐づく機能の集合 |
| メトリクス種別 (UsageMetricType) | APIコール数/ストレージ使用量 等 | 列挙型 |
| 日割り調整 (ProratedAdjustment) | 調整金額, 対象期間, 旧プラン, 新プラン | プラン変更時の計算結果 |
| クレジットカード情報 (PaymentMethod) | トークン化されたカード情報, 有効期限, ブランド | 外部決済との連携用。生のカード番号は保持しない |

#### 集約と境界の理由

| 集約ルート | 含まれるもの | 境界の理由・注意点 |
|---|---|---|
| **Plan** | Plan + FeatureSet | プランはマスタデータ。全テナントから参照される。変更頻度が低く、独立して管理できる。 |
| **Tenant** | Tenant + Membership + PaymentMethod | テナントの基本情報とメンバー構成は一体で管理。メンバーの追加・削除時にユーザー数上限のチェックが必要なため、Subscription（現在のプラン情報）を参照する。**注意**: メンバー数が数百人規模になると集約が大きくなるが、「メンバー追加時のユーザー数上限チェック」という不変条件があるため、安易に分離できない。対策としては①参照のみ Subscription から上限を取得して Tenant 集約内で判定、②結果整合性で非同期チェック、のいずれか。 |
| **Subscription** | Subscription + ProratedAdjustment | サブスクリプションのライフサイクル（プラン変更・更新・解約）を管理。Tenant とは別集約にすることで、課金関連の処理がテナント管理に影響しない。 |
| **Invoice** | Invoice + InvoiceLineItem | 請求書と明細は一体で確定される。確定後は不変（追記不可）。 |
| **PaymentAttempt** | PaymentAttempt 単体 | 決済の試行履歴。請求書に対して複数回のリトライがあるが、各試行は独立した記録。 |
| **UsageRecord** | UsageRecord 単体 | 利用量データは高頻度で蓄積される。他の集約と独立して書き込み性能を確保する必要がある。 |
| **User** | User 単体 | ユーザー情報は独立管理。複数テナントに所属する可能性もある。 |

#### ドメインイベント

- `TenantSignedUp` — テナントが作成された（→ フリープラン Subscription 作成）
- `MemberInvited` — メンバーが招待された
- `MemberRemoved` — メンバーが削除された
- `PlanUpgraded` — プランがアップグレードされた（→ 日割り調整の計算）
- `PlanDowngradeScheduled` — ダウングレードが予約された
- `PlanDowngradeApplied` — 期間終了時にダウングレードが適用された
- `SubscriptionRenewed` — サブスクリプションが自動更新された（→ 請求書生成トリガー）
- `InvoiceGenerated` — 請求書が生成された（→ 自動課金トリガー）
- `PaymentSucceeded` — 決済が成功した
- `PaymentFailed` — 決済が失敗した（→ リトライスケジュール開始）
- `PaymentDelinquent` — 3回失敗、滞納状態に移行（→ サービス制限）
- `TenantSuspended` — 滞納30日経過、停止状態
- `TenantDataDeletionScheduled` — 停止90日経過、データ削除予約
- `CancellationScheduled` — 解約が予約された
- `SubscriptionCancelled` — 期間終了時に解約が確定した
- `UsageRecorded` — 利用量が記録された
- `UsageAggregated` — 月末に利用量が集計された（→ 請求明細に反映）

#### ドメインサービス

| サービス | 責務 |
|---|---|
| **プラン変更サービス (PlanChangeService)** | アップグレード: 日割り差額を計算し、Subscription のプランを即時変更、調整額を記録する。ダウングレード: ユーザー数上限の事前チェックを行い、Subscription にダウングレード予約を設定する。 |
| **請求書生成サービス (InvoiceGenerationService)** | 更新時に基本料金 + 前月の従量課金集計 + 日割り調整額 + 税額を合算して Invoice を生成する。Subscription・UsageRecord・税率情報を横断的に参照する。 |
| **決済リトライサービス (PaymentRetryService)** | 課金失敗時のリトライを管理する。3日間隔で最大3回。全失敗時に PaymentDelinquent イベントを発行。外部決済プロバイダとの連携を抽象化。冪等性が必須。 |
| **テナントライフサイクルサービス (TenantLifecycleService)** | 滞納→停止→データ削除の状態遷移をスケジューラと連携して管理する。解約後のデータ保持期間の管理も担う。 |
| **利用量集計サービス (UsageAggregationService)** | 月末に各テナントの UsageRecord を集計し、従量課金の明細データを生成する。大量データの集計処理。バッチ実行。 |
| **日割り計算サービス (ProrationCalculator)** | プラン変更時に、残り日数と新旧プランの日額の差を計算する。計算ロジックをポリシーとして独立させる。 |

#### 設計判断の解説

**1. プラン変更時の日割り計算**

```
アップグレード（即時適用）:
  残り日数 = 次回更新日 - 今日
  日額差分 = (新プラン月額 - 旧プラン月額) / 月の日数
  調整額 = 日額差分 × 残り日数
  → ProratedAdjustment として記録し、次回請求に加算

ダウングレード（期間終了時適用）:
  1. ダウングレード先プランのユーザー数上限を確認
  2. 現在のメンバー数が上限を超えていたら拒否
  3. Subscription に「ダウングレード予約」を設定
  4. 期間終了時にスケジューラが適用
```

- ProrationCalculator を独立させる理由: 日割り計算のルールは変更されやすい（日割り方式、端数処理、無料期間の扱い等）。ポリシーとして分離しておくと変更に強い。

**2. 課金失敗時のリトライと状態遷移**

```
決済失敗 → PaymentFailed
  ├── 3日後リトライ(1回目) → 成功 → PaymentSucceeded
  ├── 3日後リトライ(2回目) → 成功 → PaymentSucceeded
  └── 3日後リトライ(3回目) → 失敗 → PaymentDelinquent
        └── テナントステータス → 「支払い滞納」
              ├── 30日経過 → TenantSuspended（停止）
              └── 停止後90日 → TenantDataDeletionScheduled
```

- 各リトライは PaymentAttempt として独立して記録する。これにより、リトライの履歴が追跡可能になる
- リトライサービスは冪等でなければならない（同じ試行を二重実行しない）
- 滞納→停止→削除の遷移はスケジューラ（cron / delayed job）で実現。TenantLifecycleService がイベントを発行する

**3. 従量課金の集計**

```
日次/リアルタイム: 利用量を UsageRecord に追記
月末バッチ:       UsageAggregationService が集計
翌月請求:         InvoiceGenerationService が基本料金 + 従量分 + 調整額で Invoice 生成
```

- UsageRecord は書き込み頻度が非常に高い（API コール数なら秒単位）。他の集約と完全に分離し、書き込み性能を確保する
- 集計はバッチ処理で行う。リアルタイム性は不要（月末締め翌月請求）
- 集計結果は InvoiceLineItem として請求書に組み込まれる。元データ（UsageRecord）と集計結果は別々に保持する

---

## 総合チェックリスト（第3回追加項目含む）

| # | チェック項目 |
|---|---|
| 1 | 要件中の主要な名詞をすべて検討したか |
| 2 | エンティティと値オブジェクトの区別は「一意に追跡する必要があるか」で判断したか |
| 3 | 集約の境界は「一緒に変更されるもの」で引けているか |
| 4 | 集約が大きすぎて更新競合のリスクはないか |
| 5 | ステータス遷移を列挙型の値オブジェクトで表現しているか |
| 6 | 時点で変わるデータ（価格等）のスナップショットを取っているか |
| 7 | 外部システム連携の情報を値オブジェクトで保持しているか |
| 8 | 集約をまたぐロジックをドメインサービスに切り出しているか |
| 9 | 結果整合性が必要な箇所を特定し、ドメインイベントで繋いでいるか |
| 10 | 冪等性・リトライが必要な処理を意識しているか |
| 11 | **時間に依存する処理**（期限切れ、スケジュール実行）の実現方法を考えたか |
| 12 | **バッチ処理 vs リアルタイム処理**の判断は適切か |
| 13 | **マスタデータ**（プランなど）と**トランザクションデータ**を区別しているか |
| 14 | **状態遷移が複数段階にまたがる**場合のオーケストレーションを設計したか |
